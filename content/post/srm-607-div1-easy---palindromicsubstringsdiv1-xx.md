+++
title = "SRM 607 DIV1 Easy - PalindromicSubstringsDiv1 xx"
date = 2014-02-05T22:34:00Z
updated = 2015-07-28T04:11:55Z
tags = ["回文"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=12964&amp;rd=15840" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=12964&amp;rd=15840</a><br /><br />ある文字列が与えられる。<br />文字列はアルファベットと、？からなり、？には任意の文字を入れることができる。<br /><br />？に任意の文字が入れられたとき、<br />その文字列中の回文であるサブ文字列の数の期待値を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />文字列は最大５０００であるため、？の全ての場合に対して期待値を求めては間に合わない。<br /><br />ここで回文の判定については、その両端の２つの文字列だけを見ればよいことがわかる。<br />ある文字列が回文であれば、その両端の文字の判定結果をかけていけば回文の判定は時間内に間に合う。<br /><br />データ構造としてdp[i][j]をi番目からj番目までの文字列、と定義することで<br />計算量は最大で5000*5000/2になるので時間内に解くことができる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">double dp[5010][5010];<br />string s;<br /><br />class PalindromicSubstringsDiv1 {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double calc(int i,int j){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(s[i]!='?'&amp;&amp;s[j]!='?') return s[i]==s[j] ? 1.0 : 0.0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return 1.0/26.0;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double expectedPalindromes(vector&lt;string&gt; S1, vector&lt;string&gt; S2) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=0.0;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp,0,sizeof(dp));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>s="";<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,S1.size())s+=S1[i];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,S2.size())s+=S2[i];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=s.size();<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>dp[i][i]=1.0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret+=dp[i][i];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n-1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>dp[i][i+1]=calc(i,i+1);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret+=dp[i][i+1];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(len,3,n+1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int i=0;i+len-1&lt;n;i++){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int j=i+len-1;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>dp[i][j]=dp[i+1][j-1]*calc(i,j);<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>ret+=dp[i][j];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
