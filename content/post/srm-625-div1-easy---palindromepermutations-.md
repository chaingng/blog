+++
title = "SRM 625 DIV1 Easy - PalindromePermutations (×)"
date = 2014-11-05T10:01:00Z
updated = 2015-04-03T11:03:08Z
tags = ["回文"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=11856&amp;rd=15858" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=11856&amp;rd=15858</a><br /><br />・ある文字列が与えられる。<br />・この文字をシャッフルした時に、回文となる確率を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />・まず与えられた文字列が回文となるかどうか判定する必要がある。<br />・すべてのアルファベットについて出現回数を調べる。<br />・このとき、すべてのアルファベットの出現回数が偶数回なら回文となる。<br />　また、奇数回出現するアルファベットが１つだけなら回文となる。<br />　それ以外は回文とならない。<br />・次に、回文となるときの確率を求める。<br /><div><br /></div>→System Failed<br /><br />・まず奇数回出現するアルファベットがある場合、その中央にそのアルファベットを<br />　置く必要がある。その確率はその出現回数／文字列長。<br />　そこから出現回数と文字列長をデクリメントする。<br /><br />・あとはすべてのアルファベットが偶数回の出現回数となる。<br />　あるアルファベット２つ置く時、それが回文となるのはひとつアルファベットを置いたときに<br />　一意に定まる。<br />　よって、ひとつアルファベットを置かれたとき、そのあと残りのアルファベットを指定の場所に置く　<br />　ので(出現回数-1)/(L-1)となる。<br />&nbsp; （例）<br />　L(文字列長)=4 ,アルファベットaのcnt(出現回数)=2のとき<br />　すべての並び：aaxx, axax, axxa, xaax, xaxa, xxaa<br />　うち回文のもの：axxa, xaax<br />&nbsp; つまり(cnt-1)/(L-1)となる。<br /><br />・反省：確率の計算の基本が・・・。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />class PalindromePermutations {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double P(int x){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=1.0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,x+1)ret*=i;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double palindromeProbability(string word) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=word.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int a[26]={};<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)a[word[i]-'a']++;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int flag=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,26)if(a[i]%2)flag++;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(flag&gt;1)return 0;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int L=n;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=1.0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(flag){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,26)if(a[i]%2){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>ret=(double)a[i]/L;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>L--;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>a[i]--;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,26)while(a[i]){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret*=(double)(a[i]-1)/(L-1);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>L-=2;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>a[i]-=2;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
