+++
title = "防御的プログラミング(CodeCompleteのまとめ)"
date = 2017-01-22T12:04:00Z
updated = 2017-01-22T19:44:08Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">CodeComplete 第8章防御的プログラミングのまとめ。<br /><br />防御的プログラミングとは、「そうなるはずだ」と決めつけないこと、<br />防御運転にヒントを得たものである。<br /><br /><h2 style="text-align: left;">無効な入力への防御</h2>「ゴミ入れ、ゴミ出し」を行うコードは書かない。<br />代わりに、「ゴミ入れ、なにも出さない」、「ゴミ入れ、エラーメッセージをだす」、「ゴミ入れ禁止」を採用する。<br /><br /><div style="text-align: left;">ゴミ入れに対処する方法</div><br /><ul style="text-align: left;"><li>外部ソースからのデータをすべて確認する</li><li>ルーチン（外部ソースではない）のすべての入力値を確認する</li><li>不正な入力を処理する方法を検討する</li><ul><li>　8.3エラー処理テクニックの１０のうちのいずれかの方法を採用</li></ul></ul><h2 style="text-align: left;"></h2><h2 style="text-align: left;">アサーション</h2>アサーションは、大きくて複雑なプログラムや特に高い信頼性が求められるプログラムでは特に効果的。<br /><br />アサーションのガイドライン<br /><br /><ul style="text-align: left;"><li>予想される状況にはエラーコードを用い、予想されない状況にはアサーションを用いる</li><li>アサーションに実行コードを埋め込まない</li><ul><li>なぜなら、デバッグモードをオフにした時にコンパイルされないことがある</li></ul><li>事前条件と事後条件の文書化に使う</li><li>ルーチンの最初にアサーションを定義する</li><li>堅牢性の高いコードはアサーションしてから処理する</li></ul><h2 style="text-align: left;"></h2><h2 style="text-align: left;">エラー処理テクニック</h2>エラー処理テクニックのガイドライン。<br /><br /><ol style="text-align: left;"><li>当たり障りのない値を返す</li><li>次に有効なデータで代替する</li><li>前回と同じ値を返す</li><li>有効な値のうち、もっとも近いもので代用する</li><li>ファイルに警告メッセージを記録する</li><li>エラーコードを返す</li><li>エラー処理ルーチンを呼び出す</li><li>発生した場所でエラーメッセージを出す</li><li>ローカルでもっともうまくいく方法でエラーを処理する</li><li>処理を中止する</li></ol><br /><br />堅牢性と正当性のどちらを担保するか最初に設計する。<br />そして上位レベルのエラー処理を設計する。<br /><br />堅牢性とは、ソフトウェアの実行を継続するように手をつくすこと。<br />正当性とは、不正確な結果を決して返さないこと。<br /><h2 style="text-align: left;"></h2><h2 style="text-align: left;">例外</h2>例外が正常な処理としてあつかわれているプログラムは可読性や保守性の問題から逃れられない。<br /><br />例外の利点を理解し、問題を避けるためのアドバイス。<br /><br /><ul style="text-align: left;"><li>本当に例外的状況のみエラーをスローする</li><li>例外を責任逃れて使用しない</li><li>ローカルでキャッチできない例外をスローしてはいけない</li><li>コンストラクタとデストラクタで例外をスローしない</li><li>オブジェクトが完全に生成されていないとデストラクタできずメモリリークを発生させる</li><li>正しい抽象化レベルで例外をスローする</li><li>そのクラスで発生する例外に具体化する</li><li>例外メッセージに原因となるすべてのメッセージを盛り込む</li><li>空のcatchブロックをかかない</li><li>ライブラリコードがスローする例外を知る</li><li>例外レポート用ルーチンでの集中管理を検討する</li><li>プロジェクトで例外の使用方法を標準化する</li><li>例外に変わる手段を検討する</li><ul><li>最後に、プログラムに本当に例外処理が必要かを検討すること</li></ul></ul><h2 style="text-align: left;"></h2><h2 style="text-align: left;">バリケードによるエラーの被害の囲い込み</h2>検証クラスによるバリケードを設けることで、正しいものが渡されていないかもしれない信頼できないクラスから、正しいものが渡されているとする信頼できるクラスへ渡す。<br />手術室に例えると、外のものを消毒して内部に持ち込むこと。<br /><br />入力データは入力されたらすぐに正しい型に変換する。<br />なぜなら、誰かがデータを変換してプログラムをクラッシュさせる危険が高まるため<br /><br />バリケードの外側は何かを想定するのは危険なので、エラー処理を行う。　<br />内側は安全なはずなので、アサーションを行う。<br /><h2 style="text-align: left;"></h2><h2 style="text-align: left;">デバッグエイド</h2>デバッグエイドとはデバッグを補助するツールで、エラーをすばやく検出するための心強い味方になる。<br />製品バージョンと開発バージョンは求めるパフォーマンスやリソースが異なるので、製品の制約を開発に当てはめない。<br />デバッグエイドの導入は早ければ早い方が良い。<br /><br />攻撃的プログラミングを使う。<br />開発中に例外状況を明確にし、コードの実行中に回復できるようにする。<br />通常は、動かないプログラムのほうが欠陥のないプログラムよりもずっと問題は少ない。<br /><br />攻撃的プログラミングのガイドライン。<br /><br /><ul style="text-align: left;"><li>アサーションを使ってプログラムを中断する</li><li>メモリ割当のエラーを検出できるようにする</li><li>ファイルフォーマットのエラーをすべて検出できるようにする</li><li>条件分岐のelse defaultを激しく失敗させる</li><li>オブジェクトを削除するまえにジャンクデータを設定する</li><li>エラーログファイルが自分あてにメールされるようにする</li></ul><br /><br />デバッグエイドの削除計画を立てる。以下の方法が有効。<br /><br /><ul style="text-align: left;"><li>　製品版ではデバッグコードをとりのぞく</li><li>　プリプロセッサで簡単に切り替える</li><li>　デバッグ用のスタブを使用する</li></ul><h2 style="text-align: left;"></h2><h2 style="text-align: left;">製品コードに防御的プログラミングをどれくらい残すか</h2>開発段階ではエラーを見逃さないように醜悪に目立たせるようにしたい。<br />しかし製品段階ではエラーを目立たないようにしてプログラムを回復させるか上品に終わらせたい、という矛盾に応える<br /><br />どれを製品コードに残すかのガイドライン。<br /><br /><ul style="text-align: left;"><li>重要なエラーを検査するコードは残す</li><li>ささいなエラーを検知するコードは削除する</li><li>処理を中断するコードは削除する</li><li>致命的なエラーを検出するデバッグコードが含まれるとき、プログラムを上品にクラッシュさせるコードがあれば残す</li><li>テクニカルサポート編集者のためのエラーを記録する</li><li>わかりやすいエラーメッセージは残す</li></ul><h2 style="text-align: left;"></h2><h2 style="text-align: left;">防御的プログラミングに対する防御</h2>複雑性が増え、そして防御的コードにもまたエラーの可能性を含むため<br />あまりにもチェックが多いとコードは肥大化する。<br />そのため、優先順位を設定する</div>
