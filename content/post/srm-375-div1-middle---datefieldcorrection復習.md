+++
title = "SRM 375 DIV1 Middle - DateFieldCorrection　（復習○）"
date = 2014-05-12T23:00:00Z
updated = 2014-06-06T08:00:49Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />キーボードで「”月”　”日”」を打ちたいが、タイプミスをしばしば起こしてしまう。<br />タイプミスはキーボードの隣り合う文字についてはコスト１、スペースとの間は３のコストで定義される。<br /><br />タイプ後の文字が与えられるとき、最もコストの少ない、つまり打とうとしていた「”月”　”日”」を求める。ただし同じコストの場合は最も早い月日を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />実装の問題なので、いかにシンプルに考えて、シンプルに実装するか。<br /><br />まず問題文にキーボード間のコストが図で載っているが、<br />これを以下に簡単に定義できるかが課題。<br />キーボードをみてみると、キーボードの行単位で考えることができそう。<br />各行に対し、隣り合う文字とのコストは１となる。<br />各行に対し、真下の行の文字とのコストは１となる。<br />各行に対し、真下の行の左下の文字とのコストは１となる。<br />一番下の行について、スペースとのコストは３となる。<br /><br />また英数字は８ビットで表わせるので、int型の配列d[256][256]を定義し<br />配列番号はアルファベット、値は距離としてあげればコストをグラフで定義できる。<br />最後にワーシャルフロイドを回せば各文字間の最短距離が求められる。<br /><br />最後にすべての月、日に対してアウトプット「”月”、”日”」の文字列を用意し<br />与えられた文字inputと文字列長が同じであればコストを計算すればよい。<br /><br />最後に大文字と小文字の区別をなくすように、tolower関数を使うことに注意。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />int d[256][256];<br /><br />class DateFieldCorrection {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int rec(string str1,string str2){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ret=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,str1.size())ret+=d[tolower(str1[i])][tolower(str2[i])];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>string correctDate(string input) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>string keys[]={"1234567890","qwertyuiop","asdfghjkl","zxcvbnm"};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>string month[]={"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int day[]={31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,256)FORE(j,0,256)d[i][j]=((i==j) ? 0 : 1e+9);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,4)for(int j=0;keys[i][j+1]!='\0';j++)<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>d[keys[i][j]][keys[i][j+1]]=min(d[keys[i][j]][keys[i][j+1]],1);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,3)for(int j=0;keys[i][j]!='\0'&amp;&amp;keys[i+1][j]!='\0';j++)<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>d[keys[i][j]][keys[i+1][j]]=min(d[keys[i][j]][keys[i+1][j]],1);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,3)for(int j=1;keys[i][j]!='\0'&amp;&amp;keys[i+1][j-1]!='\0';j++)<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>d[keys[i][j]][keys[i+1][j-1]]=min(d[keys[i][j]][keys[i+1][j-1]],1);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>for(int j=1;keys[3][j]!='\0';j++)d[keys[3][j]][' ']=min(d[keys[3][j]][' '],3);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,256)FORE(j,0,256)d[i][j]=min(d[i][j],d[j][i]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(k,0,256)FORE(i,0,256)FORE(j,0,256)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int best=1e+9;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>string ret="";<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,12)FORE(j,1,day[i]+1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>char ch[100];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>sprintf(ch,"%s %d",month[i].c_str(),j);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(strlen(ch)==input.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int cost=rec(ch,input);<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(cost&lt;best){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>best=cost;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>ret=ch;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
