+++
title = "SRM 228 DIV1 Middle -BagsOfGold　（復習××）"
date = 2014-03-15T13:49:00Z
updated = 2014-09-03T15:37:55Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://topcoder.bgcoder.com/print.php?id=768" target="_blank">http://topcoder.bgcoder.com/print.php?id=768</a><br /><br />ゴールドの山が順に並んでいる。<br />あらかじめ、それぞれの山にどれだけゴールドがあるかわかっている。<br /><br />２人でこのゴールドの山の取りあいを行い、最初は自分のターン。<br />左端か右端のいずれかを選び、相手のターンに移る。<br /><br />どちらも最適な選択をしたとき、自分が得られるゴールドと相手が得られるゴールドの差の最大値を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />ｄｐの問題だが、自分のターンと相手のターンで選び方が異なる。<br />ターンの区別をなくし、次のターンは必ず相手は最善の選び方をすると考える。<br /><br />そうすると、左端を選んだときに左端のスコアから相手が得られる最大のゴールドを引いたものと、右端を選んだときに右はじのスコアと相手から得られる最大のゴールドを引いたもののうち、最大のものを返してあげればよい。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />vector&lt;int&gt; b;<br />int dp[51][51];<br /><br />class BagsOfGold {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int calc(int left,int right){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(left==right)return b[left];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(dp[left][right]!=-1)return dp[left][right];<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return dp[left][right]=max(b[left]-calc(left+1,right),b[right]-calc(left,right-1));<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int netGain(vector&lt;int&gt; bags) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>b=bags;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=bags.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp,-1,sizeof(dp));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return calc(0,n-1);<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
