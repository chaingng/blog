+++
title = "SRM 289 DIV1 Easy - FallingBall"
date = 2014-02-01T08:44:00Z
updated = 2015-03-26T19:54:38Z
tags = ["DP"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />・トライアングル上に釘が打ってある台からボールを落とす。<br />・台の高さはあらかじめ与えられる。<br />・ボールを落としたとき、下に落ちる場所は釘の左側か右側になる。<br />・また、通って欲しい釘の場所が複数与えられる。<br />・このとき、通って欲しい場所を通るボールの落ち方の場合の数を求める。<br />　そのような場合がない場合はー１を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />パスカルの三角形を使えば解くことができる。<br /><br />最初に与えられた台の数のパスカルの三角形を作り、<br />各座標の差だけパスカルの三角形の場合の数をかけていく。<br />座標の差が通ることができない差であればー１を返す。<br /><br />最後に、台の高さと最後の座標の高さの差の数だけ２の階乗すれば答えが求まる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class FallingBall {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int howMany(vector&lt;string&gt; cells, int n) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ret=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;pair&lt;int,int&gt; &gt; p;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int dp[n+1][n+1];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp,0,sizeof(dp));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>dp[0][0]=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,n+1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>dp[i][0]=1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(j,1,n+1)dp[i][j]=dp[i-1][j-1]+dp[i-1][j];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,cells.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>stringstream out(cells[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int a,b;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>out&gt;&gt;a&gt;&gt;b;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>p.push_back(make_pair(a,b));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>p.push_back(make_pair(0,0));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(all(p));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,p.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int dy=p[i].first-p[i-1].first;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int dx=p[i].second-p[i-1].second;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(dx&lt;0||dx&gt;dy)return 0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret*=dp[dy][dx];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret*(1&lt;&lt;(n-1-p[p.size()-1].first));<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
