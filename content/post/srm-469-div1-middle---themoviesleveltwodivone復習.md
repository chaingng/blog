+++
title = "SRM 469 DIV1 Middle - TheMoviesLevelTwoDivOne　（復習×）"
date = 2014-05-01T21:47:00Z
updated = 2014-06-06T08:00:03Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />プレイヤーは複数存在するホラー映画を観る。<br /><br />各ホラー映画について、映画の長さlengthと恐いシーンが出現するときの映画開始からの長さscaryが与えられる。<br /><div>長さscaryまで起きて入れば恐さの値が47加算される。</div><br />プレイヤーは最初に恐さの値を74持つ。<br />１分ごとに恐さの値が１ずつ減っていき、－１になると寝てしまい他の映画は見れなくなる。<br /><div><br /></div>このとき、できるだけ多くの映画を観ることができる順番を求める。<br />複数存在するときは辞書順に小さいものを返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />映画の数は20なので、ビット列ｄｐがなんとなく使えそう。<br />ただし順番を求めるため、ｄｐの値に配列を持つとメモリが足りなくなってしまう。<br /><br />そこで、「映画を観た本数」の配列と「そのうち辞書順で最小の映画の順番」の配列を用意し、状態として「これまでに観た映画のビット列」を持たせる。<br /><br />最後に逆順にたどることで、順番を復元することができる。<br /><br /><span style="color: red;">ｄｐで求めたい値が２つある場合は、今回のように最小の「映画の順番」、「映画を観た本数」の２つのｄｐを用意して解く。</span><br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />int c[(1&lt;&lt;20)+1],first[(1&lt;&lt;20)+1];<br /><br />class TheMoviesLevelTwoDivOne {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>vector&lt;int&gt; find(vector&lt;int&gt; length, vector&lt;int&gt; scary) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=length.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(c,0,sizeof(c));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(first,0,sizeof(first));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>for(int i=1;i&lt;(1&lt;&lt;n);i++){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int bestcount=-1,bestfirst=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int score=74;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int j=0;j&lt;n;j++)if(!(i&amp;(1&lt;&lt;j)))score+=(47-length[j]);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int j=0;j&lt;n;j++){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(i&amp;(1&lt;&lt;j)){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>int count=0;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>if(score&gt;=scary[j]&amp;&amp;score+47-length[j]&gt;=0){<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>count=c[i-(1&lt;&lt;j)]+1;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>if(count&gt;bestcount){<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>bestcount=count;<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>bestfirst=j;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>c[i]=bestcount;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>first[i]=bestfirst;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; ret;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int x=(1&lt;&lt;n)-1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>while(x&gt;0){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret.push_back(first[x]);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>x=x-(1&lt;&lt;first[x]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
