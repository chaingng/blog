---
title: "[python] pep8規約まとめ"
date: 2020-08-08T10:00:00+09:00
tags: [ "python"]
---

Pythonのコードスタイルガイド[pep8](https://pep8-ja.readthedocs.io/ja/latest/)のまとめ。

## インデント

1レベルインデントするごとに、スペースを4つ使いましょう。

行を継続する場合は、折り返された要素を縦に揃えるようにすべきです。

正しい
```
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
```

間違い
```
foo = long_function_name(var_one, var_two,
    var_three, var_four)
```


## 突き出しインデントを使う場合は、はじめの行には引数を付けずに次の行以降をインデントし、継続行だとはっきりわかるようにしましょう。


突き出しインデント は、はじめの行以外の全ての行をインデントするDTPのやり方です。Python の文脈では、括弧で囲む文の開き括弧を行の終わりに置いて、残りの行を閉じ括弧までインデントするスタイルのことを言います。

```
# 突き出しインデントはインデントのレベルを深くする
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

```
# 突き出しインデントはインデントのレベルを深くする
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

## 波括弧/ブラケット/括弧 を閉じる時は、「リストの最後の要素が置かれた行の、はじめのホワイトスペースでない文字の直下」に閉じる記号を置いても構いません。

```
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```

## 閉じる記号を「継続された行のはじめの文字」に合わせて置いても構いません。

```
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

## タブか、スペースか?スペースが好ましいインデントの方法です。

- Python 3 では、インデントにタブとスペースを混ぜることを禁止しています。
- インデントにタブとスペースを混ぜた Python 2 のコードは、スペースだけを使うように変換すべきです。
- Python 2 のコマンドラインインタプリタを -t オプションを付けて呼び出すと、タブとスペースをインデントに混ぜたコードに対して警告を出します。-tt を付けるとエラーになります。これらのオプションの使用を強く推奨します！

## 1行の長さ。すべての行の長さを、最大79文字までに制限しましょう。
- エディタのウィンドウの幅を制限すると、複数のファイルを並べて開くことができ、二つのバージョンを隣り合ったカラムに表示するコードレビューツールを使うときにもうまくいきます。
- ほとんどのツールのデフォルトの折り返し動作は、コードの見た目の構造を壊し、理解するのを難しくします。79文字という制限は、ウィンドウの幅を80に制限し、行を折り返すときにツールが行末にマーカーを置いたとしても、エディタに折り返す動作をさせない目的で選ばれています。
- Python の標準ライブラリは保守的なので、1行の文字数は79文字に制限することが必須です(docstring やコメントは72文字)。

## 長い行を折り返す好ましい方法は、Pythonが括弧やブラケット、波括弧の中では暗黙のうちに行を継続させることを利用することです。
- 長い行は文を括弧で囲むことで、複数行に分割できます。行を継続させるには、バックスラッシュよりもこれらを使用すべきです。

## 段落の中にある式は、常に2項演算子や関係演算子の後で改行しますが、構造化された式は常に2項演算子の前で改行します

この数学の伝統に従うと、通常はもっと読みやすいコードになります:

```
# 正しい:
# 演算子とオペランドを一致させやすい
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

```
# 間違い:
# 演算子がオペランドと離れてしまっている
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```

## トップレベルの関数やクラスは、2行ずつ空けて定義するようにしてください。

## クラス内部では、1行ずつ空けてメソッドを定義してください。

## 関数の中では、ロジックの境目を示すために、空行を控えめに使うようにします。

## Python のコアディストリビューションに含まれるコードは常に UTF-8 (Python 2 では ASCII) を使用すべきです。
- ASCII (Python 2) や UTF-8 (Python 3) を使用しているファイルにはエンコーディング宣言を入れるべきではありません。

## import文は、通常は行を分けるべきです:

```
# 正しい:
import os
import sys
```

```
# 悪い:
import sys, os
```

## １つのサブモジュールからインポートする場合は、行を分けなくてよい


```
# 正しい:
from subprocess import Popen, PIPE
```

## import文 は常にファイルの先頭、つまり モジュールコメントや docstring の直後、そしてモジュールのグローバル変数や定数定義の前に置くようにします。

## import文 は次の順番でグループ化すべきです:

1. 標準ライブラリ
2. サードパーティに関連するもの
3. ローカルな アプリケーション/ライブラリ に特有のもの

上のグループそれぞれの間には、1行空白を置くべきです。

## 絶対import を推奨します
なぜなら、絶対import の方が通常は読みやすく、importシステムが正しく設定されなかった(たとえばパッケージ内部のディレクトリが sys.path で終わっていた) 場合でも、より良い振る舞いをする(または少なくともより良いエラーメッセージを出す)からです:

```
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

## クラスを含んだモジュールからクラスをimportする場合

次のようにしても通常はOKです:
```
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

このやり方で名前の衝突が起きたら、次のように明示的にimportします:

```
import myclass
import foo.bar.yourclass
```

## ワイルドカードを使った import (from <module> import *) は避けるべきです。

- なぜなら、どの名前が名前空間に存在しているかをわかりにくくし、コードの読み手や多くのツールを混乱させるからです。
- ワイルドカードを使った import を正当化できるユースケースがひとつあります。内部インターフェイスを公開APIとして再公開する場合 (たとえば、Pure Python の実装をオプションの高速化モジュールの内容で上書きし、どの定義が上書きされるかがあらかじめわからない場合) です。

## モジュールレベルの "二重アンダースコア変数" (変数名の前後にアンダースコアが2つ付いている変数) は、モジュールに関する docstring の後、そして from __future__ 以外の あらゆるimport文の前に置くべきです。
- Python はfuture importを、docstring 以外のあらゆるコードの前に置くように強制します:

```
"""This is the example module.

This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys

```

## 三重引用符 で文字列を囲むときは、PEP 257 での docstring に関するルールと一貫させるため、常に二重引用符 """ を使うようにします。


## 括弧やブラケット、波括弧 のはじめの直後と、終わりの直前に、余計な空白文字を使うのはやめましょう

```
# 正しい:
spam(ham[1], {eggs: 2})
```

```
# 間違い:
spam( ham[ 1 ], { eggs: 2 } )
```

## 末尾のカンマと、その後に続く閉じカッコの間に、余計な空白文字を使うのはやめましょう

```
# 正しい:
foo = (0,)
```

```
# 間違い:
bar = (0, )
```

## カンマやセミコロン、コロンの直前に、余計な空白文字を使うのはやめましょう

```
# 正しい:
if x == 4: print x, y; x, y = y, x
```

```
# 間違い:
if x == 4 : print x , y ; x , y = y , x
```

## スライスではコロンは二項演算子のように振る舞います。よって、(コロンは優先度が最も低い演算子として扱われるので)両側に同じ数(訳注: 無しでも可だと思われる)のスペースを置くべきです。

```
# 正しい:
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```
```
# 間違い:
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]
```

## 関数呼び出しの引数リストをはじめる開き括弧の直前に、余計な空白文字を使うのはやめましょう

```
# 正しい:
spam(1)
```
```
# 間違い:
spam (1)
```

## インデックスやスライスの開き括弧の直前に、余計な空白文字を使うのはやめましょう

```
# 正しい:
dct['key'] = lst[index]
```
```
# 間違い:
dct ['key'] = lst [index]
```

## 代入(や他の)演算子を揃えるために、演算子の周囲に1つ以上のスペースを入れることはやめましょう

```
# 正しい:
x = 1
y = 2
long_variable = 3
```
```
# 間違い:
x             = 1
y             = 2
long_variable = 3
```

## 行末に余計な空白文字を残さないようにしましょう
- 通常それは目に見えないため、混乱のもとになるかもしれません。たとえば、バックスラッシュの後にスペースをひとつ入れて改行してしまうと、行を継続すると見なされません。
- エディタによっては行末の余計な空白文字を保存しないものもありますし、多くのプロジェクト (CPythonもそうです) ではコミット前のフックでそれを拒否するように設定しています。


