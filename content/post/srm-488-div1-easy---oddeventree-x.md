+++
title = "SRM 488 DIV1 Easy - OddEvenTree x"
date = 2015-05-06T12:30:00Z
updated = 2015-08-09T20:58:01Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13759&amp;rd=16461" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=13759&amp;rd=16461</a><br /><br />N個のノード、N-1のエッジからなる木がある。<br />どのノードとエッジが接続しているかわからないが、各ノード間の距離が<br />偶数ならE,奇数ならOであるという情報が与えられている。<br /><br />このとき、与えられた情報で木が再現できるならそのエッジの例を一つ出力する。<br />そうでない場合はー１を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />まずは木でつながっていることから、一つの木（例えばノード０）からのエッジが<br />すべてEなら再現できない。<br /><br />上記を満たす場合、一つのノード０を基準にして、<br />・ノード０からの距離が偶数同士のノード間エッジはE<br />・偶数と奇数であればO<br />・奇数同士であればE<br /><br />であるか判定し、存在する場合は一つのエッジO（例えばノード０～ノード３）<br />を固定して、そこからエッジを伸ばしていけば有効なエッジの集合となる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class OddEvenTree {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: vector&lt;int&gt; getTree(vector&lt;string&gt; x) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=x.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int d[n];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; invalid(1,-1);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int flag=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)if(x[0][i]=='O')flag=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(flag)return invalid;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)d[i]=(x[0][i]=='O');<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)FORE(j,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int cur=(x[i][j]=='O');<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(cur!=(d[i]^d[j]))return invalid;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int r0=0,r1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)if(x[0][i]=='O')r1=i;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; ans;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>ans.push_back(r0),ans.push_back(r1);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,n)if(i!=r1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(d[i]){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>ans.push_back(r0),ans.push_back(i);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}else{<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>ans.push_back(i),ans.push_back(r1);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
