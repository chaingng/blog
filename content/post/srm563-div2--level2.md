+++
title = "SRM563 DIV2 -Level2"
date = 2013-07-03T23:29:00Z
updated = 2015-03-26T19:59:42Z
tags = ["移動"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">＜問題＞<br />①２次元のフィールドが与えられる。<br />②フィールドにはランダムな数の障害物と、２つのコインが置かれている。<br />③プレイヤーは上下左右の操作をすることができ、１度の操作で選んだ方向に１マスだけ２つのコインを動かせる。動く先に障害物がある場合は動かない。<br />④コインが動いた時、フィールドから外れた場合はコインが落ちる。<br />⑤このとき、コインを１つだけ落としたいときの最小の操作回数を返す。<br />　ただし、操作回数が１０回を超えた時はー１を返す。<br /><br />＜解き方＞<br />動的計画法で最小の操作回数を求める。<br />単純なシミュレーションですが、いかに簡単に書いて間違いを少なくするかが<br />ポイントだと思います。<br /><br />-1となる例外の処理を再帰関数で書いた時には処理がうまくいかなかったので、<br />例外の処理はメイン関数で行う方がよさそう。<br /><br />また、vectorを渡す時には &amp;bのようにしてあげないと<br />処理がおかしくなるので注意。<br /><br />＜コード＞<br />class CoinsGameEasy {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int f(int turn,int x1,int y1,int x2,int y2,vector&lt;string&gt;&amp; b){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(turn&gt;10)return turn;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ret=11,w=b[0].size(),h=b.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int dx[]={1,-1,0,0};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int dy[]={0,0,-1,1};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,4){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int flag=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int tx1=x1+dx[i],ty1=y1+dy[i],tx2=x2+dx[i],ty2=y2+dy[i];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(tx1&lt;0 || tx1&gt;=w || ty1&lt;0 || ty1&gt;=h)flag++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(tx2&lt;0 || tx2&gt;=w || ty2&lt;0 || ty2&gt;=h)flag++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(flag==1)return turn+1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(flag==2)continue;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(b[ty1][tx1]=='#')tx1=x1,ty1=y1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(b[ty2][tx2]=='#')tx2=x2,ty2=y2;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret=min(ret,f(turn+1,tx1,ty1,tx2,ty2,b));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int minimalSteps(vector&lt;string&gt; board) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int x[2],y[2],idx=0,ret;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,board.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(j,0,board[0].size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(board[i][j]=='o'){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>x[idx]=j;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>y[idx++]=i;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>ret=f(0,x[0],y[0],x[1],y[1],board);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret&gt;10 ? -1 : ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div>
