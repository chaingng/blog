+++
title = "SRM539 DIV2 -Level2"
date = 2013-07-09T08:28:00Z
updated = 2015-04-03T11:20:04Z
tags = ["考察"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">問題<br />①数字の配列が２つ与えられる。<br />　それぞれの番号は、岩が入るＢＯＸの最小の数と最大の数を表わす。<br />②あなたは岩を無数に持っており、選んだＢＯＸに最小の数以上、<br />　最大の数まで岩を入れることができる。<br />③このとき、岩を９００１個以上入れた時に表わすことのできる<br />　岩の個数の場合の数を返す。<br /><br />解き方<br />問題文を最初ミスリーディングしてしまったのですが、<br />「９００１個以上入れることのできる場合の数」ではなく、<br />「表わすことのできる岩の個数の場合の数」になります。<br /><br />最初にこのまま全探索しても手掛かりがないため、<br />全てのＢＯＸの選び方はＯ（２＾１５＝１０＾３＊３２）で選ぶことができるため<br />選んだＢＯＸについて考える。<br /><br />そうすることで最小の岩の数と最大の岩の数がわかるため、<br />９００１以上の表わせる岩の個数がわかる。<br /><br />ただし表わせる岩の個数を配列に保存しようとすると<br />次に、岩の数は１０＾６とかなり大きいため、<br />Ｏ（１０＾６＊１０＾３＊３２）で計算できない。<br /><br />そこで、全て配列に保存するのではなく<br />範囲を保存することを考える。<br />始点の岩の数の配列を＋１とし、終点の次の配列をー１とすることで、<br />＋のときはその間の数は存在することとなる。<br /><br />この処理を全て行っていくと、<br />配列の数を最初から足していったとき＋１以上のときはその数は存在することとなる。<br /><br />Ｃｈａｌｌｅｎｇｅポイント<br />配列（ループ）の数を１０＾７＊２だとエラーになってしまいました。<br />１０＾６＊１．６だと通ったので、<br />１０＾７＊２以上にならないことがＣｈａｌｌｅｎｇｅのポイントになりそうです。<br /><br />またケアレスミスをしてしまいましたが<br />ビット列計算をするときは＆＆ではなく＆になります。<br /><br />コード<br />class Over9000Rocks {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int countPossibilities(vector&lt;int&gt; lowerBound, vector&lt;int&gt; upperBound) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=lowerBound.size(),ans=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; check(16000000,0);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>for(int select=1;select&lt;(1&lt;&lt;n);select++){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int upper=0,lower=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int j=0;j&lt;n;j++){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(select&amp;1&lt;&lt;j){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>lower+=lowerBound[j];<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>upper+=upperBound[j];<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>check[lower]++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>check[upper+1]--;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int parity=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,(int)check.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>parity+=check[i];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(i&gt;9000 &amp;&amp; parity&gt;0)ans++;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};<br /><div><br /></div></div>
