+++
title = "SRM582 DIV2 -Level1,2"
date = 2013-06-15T11:47:00Z
updated = 2013-06-15T11:47:50Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">やっと緑コーダーになれました。<br />SYSTEMテストで２回連続で落ちていて、３度目の正直。<br />Challengeを今までまったくしておらず、ちゃんとコード書けることが大事だからいらないかなと思っていました。<br />ただ、撃墜できること＝自分のコードの抜け漏れがチェックできる、ということにもつながるのでこれからはちょっと力を入れていきたいです。<br /><br />Ｌｅｖｅｌ１<br />＜問題＞<br />①２以上のある整数Ｎが与えられる。<br />②a&gt;=1,b&gt;1,a&lt;b, a*b*b=Nとなる数字が存在する場合はYes、<br />　そうでない場合はNoを返す。<br /><br />＜解き方＞<br />単純に実装するだけです。<br />全探索でもよいのですが、Yesならb*bは必ず存在するので<br />bを1からb*b&lt;=Nまでまわして判定しました。<br /><br />＜コード＞<br />class SemiPerfectSquare {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: string check(int N) {<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>for(int i=1;i*i&lt;=N;i++){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(N%(i*i)==0 &amp;&amp; N/(i*i)&lt;i)return "Yes";<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return "No";<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};<br /><br />Ｌｅｖｅｌ２<br />＜問題＞<br />①魔法少女の強さの順列、敵の強さの順列と各敵の数が与えられる。<br />②魔法少女は１匹敵を倒すたびに疲れが１増える。最初は０。<br />③このとき、全ての敵を倒した時に魔法少女の中で最も大きい疲れが最小となるものを返す。全ての敵を倒せない場合はー１を返す。<br /><br />＜解き方＞<br />全ての魔法少女が全ての敵を倒すことができる理想の状態を考えると、<br />各魔法少女は「Ｎ＝全ての敵の数／全ての魔法少女の数」の敵を倒せばよい。<br />ただそうでないケースも存在するので、その場合をシミュレーションで実装する。<br /><br />まずは魔法少女と敵を強さの昇順にソートして例外処理を行う。<br />一番強い魔法少女の強さより、最も強い敵の強さが高ければ<br />全ての敵を倒せないのでー１を返す。<br /><br />次に、魔法少女が倒すことができない敵が出た時は次の魔法少女に移り、<br />「Ｎ＝残りの敵の数／残りの魔法少女の数」を再計算してあげる。<br /><br />すべてシミュレーションが終了した時、最も高い疲れの値を返してあげればよい。<br /><br />＜関数＞<br />２つの配列について、一つの配列の値に対してソートできれば簡単になる。<br /><br />＜コード＞<br />class SpaceWarDiv2 {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int minimalFatigue(vector&lt;int&gt; mS, vector&lt;int&gt; eS, vector&lt;int&gt; eC) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector &lt;pair &lt;int, int&gt; &gt; enemy;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=0,girl=mS.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ans=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; girlF(mS.size(),0);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,eS.size())enemy.push_back(make_pair(eS[i],eC[i]));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(mS.begin(),mS.end());<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(enemy.begin(),enemy.end());<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(mS[(int)mS.size()-1]&lt; enemy[(int)enemy.size()-1].first)return -1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,enemy.size())n+=enemy[i].second;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int num=(n+girl-1)/girl;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int curg=0,cure=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int curn=num;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>while(curg&lt;mS.size() &amp;&amp; cure&lt;enemy.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(mS[curg]&gt;=enemy[cure].first){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>while(1){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>enemy[cure].second--;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>curn--;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>girlF[curg]++;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>if(enemy[cure].second==0 || curn==0){<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>if(enemy[cure].second==0)cure++;<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>if(curn==0){<br /><span class="Apple-tab-span" style="white-space: pre;">       </span>curg++;<br /><span class="Apple-tab-span" style="white-space: pre;">       </span>curn=num;<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>break;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>else{<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>curg++;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(curg==girl)break;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>n=0;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(i,cure,(int)enemy.size())n+=enemy[i].second;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>num=(n+girl-curg-1)/(girl-curg);<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>curn=num;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,(int)mS.size())ans=max(ans,girlF[i]);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};<br /><br /></div>
