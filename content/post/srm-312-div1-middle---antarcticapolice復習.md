+++
title = "SRM 312 DIV1 Middle - AntarcticaPolice　（復習××○）"
date = 2014-03-09T09:00:00Z
updated = 2014-08-24T09:01:09Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=6501&amp;rd=9992" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=6501&amp;rd=9992</a><br /><br />都市Antarcticaにポリスステーションを建てたい。<br />Antarcticaには複数の町があり、それぞれの町にポリスステーションを建てた時のコストがあらかじめわかっている。<br /><br />ただし全ての町にポリスステーションを建てる必要はなく、その他のポリスステーションからその町に行くことができれば必要ない。<br /><br />また、各町について一方通行でつながっているかどうかの情報も与えられる。<br /><br />このとき、１つのポリスステーションを建てた時の平均コストが最小になるときの値を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />無向グラフではなく有向グラフの問題。<br /><br />強連結である部分集合を求め、その他の集合からたどりつけない集合であればその部分集合から最小のコストを足す必要がある。<br /><br />最後に、選ばれていない町のコストについて、平均が低くなるものについてのみコストを足してあげればよい。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br /><br />class AntarcticaPolice {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double minAverageCost(vector&lt;int&gt; costs, vector&lt;string&gt; roads) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=costs.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>bool p[n][n];<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)FORE(j,0,n)p[i][j]=(roads[i][j]=='Y');<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)p[i][i]=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(k,0,n)FORE(i,0,n)FORE(j,0,n)p[i][j]|=(p[i][k]&amp;&amp;p[k][j]);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int G=0,root[n];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(root,-1,sizeof(root));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(root[i]==-1){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>root[i]=G;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(j,0,n)if(i!=j &amp;&amp; p[i][j] &amp;&amp; p[j][i])root[j]=G;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>G++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int g[n][n];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(g,0,sizeof(g));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)FORE(j,0,n)if(p[i][j])g[root[i]][root[j]]=1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int used[n];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(used,0,sizeof(used));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,G){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int in=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(j,0,G)if(i!=j &amp;&amp; g[j][i])in=1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(!in){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int tmp=-1;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(j,0,n)if(root[j]==i &amp;&amp; (tmp==-1 || costs[j]&lt;costs[tmp]))tmp=j;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>used[tmp]=1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; others;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int sum=0,num=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(used[i])sum+=costs[i],num++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>else others.push_back(costs[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(all(others));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=(double)sum/num;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,others.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>sum+=others[i],num++;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret=min(ret,(double)sum/num);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
