+++
title = "SRM 645 DIV1 Easy - JanuszTheBusinessman"
date = 2015-04-19T11:43:00Z
updated = 2015-04-19T11:44:12Z
tags = ["集合"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13603&amp;rd=16277" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=13603&amp;rd=16277</a><br /><br />ホテルに複数の人が宿泊に訪れる。<br />各ゲストについて到着日と出発日がわかっている。<br /><br />ここで、ホテルでプロモーションを行うことができ、プロモーションを行うとその日に宿泊している人はよいレビューを残してくれる。<br /><br />また、プロモーションを受けた人とそうでない人の宿泊日が重なると、プロモーションを受けていない人もよいレビューを残してくれる。<br /><br />このとき、すべての宿泊客がよいレビューを残してくれる最小のプロモーション開催日数を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />条件を満たす集合の数を求めていけばよい。<br />プロモーションを「直接」受けている人と宿泊日が重ならなければ<br />よいレビューを残さないことに注意。<br /><br />まず、プロモーションの開催日を求める。<br />このとき、一番早く出発する人からプロモーション日を求めていけば貪欲法で解ける。<br /><br />プロモーション日が決まったら、そのプロモーションを直接受けられる宿泊客のうち<br />最も遅く出発する日を求める。<br /><br />その最も遅い出発日と重なる宿泊客は同じ集合にすることができ、<br />このオペレーションの回数が最小のプロモーション開催日数となる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class JanuszTheBusinessman {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int makeGuestsReturn(vector&lt;int&gt; arrivals, vector&lt;int&gt; departures) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=arrivals.size();<br />&nbsp; &nbsp; &nbsp; &nbsp; int ok[n];<br />&nbsp; &nbsp; &nbsp; &nbsp; memset(ok,0,sizeof(ok));<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; int ret=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; while(true){<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>int promday=1e+9;<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>FORE(i,0,n)if(!ok[i])promday=min(promday,departures[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>if(promday==1e+9)break;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>int maxcover=promday;<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>FORE(i,0,n)if(arrivals[i]&lt;=promday &amp;&amp; promday&lt;=departures[i]){<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;">  </span>maxcover=max(maxcover,departures[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>FORE(i,0,n)if(arrivals[i]&lt;=maxcover)ok[i]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; <span class="Apple-tab-span" style="white-space: pre;"> </span>ret++;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return ret;<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
