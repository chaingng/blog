+++
title = "SRM 570 DIV1 Easy - RobotHerb (復習××)"
date = 2013-08-18T09:35:00Z
updated = 2015-03-26T19:58:45Z
tags = ["移動"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=12427&amp;rd=15490" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=12427&amp;rd=15490</a><br /><br />ロボットが与えられた数の配列の通りに動作する。<br /><br />最初は任意の方向を向いており、配列の最初の数だけまっすぐ移動する。<br />その後、移動した分だけ左を向く。<br /><br />次の配列に移り、同じ動作をする。最後の配列まで終わったら一度の操作が終了。<br />この動作をＴ回実施する。<br /><br />最後に、最初の位置とのマンハッタン距離を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />最小・最大を求めるわけではないシミュレーション問題。<br />今回はＴが10^9と大きいので単純なシミュレーションでは解けない。<br /><br />一度の動作後に動いた座標と向きは常に一緒なので、<br />そのＴ回の繰り返しで解ける。<br /><br />４回動くと向きは戻るので、４の倍数のときは×Ｔ、<br />余りが出た場合は４の倍数から１回、２回、３回いずれかの値を足す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class RobotHerb {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: long long getdist(int T, vector&lt;int&gt; a) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int x[]={0,1,0,-1},y[]={1,0,-1,0};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int d=0,curx=0,cury=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>long long ans=0,move[4]={};<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(n,1,5){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,a.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>curx+=a[i]*x[d];<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>cury+=a[i]*y[d];<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>d=(d+a[i])%4;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>move[n%4]=abs(curx)+abs(cury);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>ans=move[0]*(T/4);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(T%4)ans+=move[T%4];<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
