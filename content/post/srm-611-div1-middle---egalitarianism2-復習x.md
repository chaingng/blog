+++
title = "SRM 611 DIV1 Middle - Egalitarianism2 （復習x）"
date = 2014-05-31T10:39:00Z
updated = 2014-06-06T07:59:41Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />Ｎ個の都市があり、すべての都市についてある都市からある都市までいけるようにしたい。<br />ただし、そのために引くエッジの距離はできるだけ差がないようにしたく、その標準偏差を最小になるようにしたい。<br /><br />このとき、最小となる標準偏差を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />標準偏差は全ての辺のコストの平均をave、一つの辺のコストをAiとすると、<br />sqrt( Σ(ave-Ai)^2 /(N-1))で求められる。<br /><br />このとき、aveの値によってどの辺を用いたらよいかの優先度が変化する。<br />そのため、すべての考えられる優先度に対して標準偏差を計算し、そのうちの最小となるものを求めればよい。<br /><br />それでは、すべての考えられる優先度を考える。<br />このとき、２辺間の優先度はその平均に対して大小があるときに変化する。<br />そのため、aveをすべての２辺間の平均＋αに仮に設定し、そのときの標準偏差をすべて求めればよい。<br /><br />このとき優先度が決定したときのグラフの作成は最小全域木を求めることと等しい。<br />よって、<a href="http://www.deqnotes.net/acmicpc/prim/" target="_blank">プリム法</a>を適用して最小全域木を求める。<br /><br /><br />最後に、標準偏差は計算にあたって以下のように変形する。<br />sqrt( Σ(ave-Ai)^2 /(N-1))<br />=sqrt( Σ(ave^2) -2*Σ(Ai)*ave+Σ(Ai)^2 /(N-1))<br />=sqrt( (n-1)ave^2-2*Σ(Ai)*ave+Σ(Ai)^2/(N-1))<br /><br /><a href="http://batmitzvah.blog136.fc2.com/blog-entry-779.html" target="_blank">数列の和の公式</a>でΣの変数にかからない項は項数の積となる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">double d[30][30],d2[30][30];<br />int n;<br /><br />class Egalitarianism2 {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>void prim(double m,double &amp;sum,long long &amp;sum2){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int used[n],prev[n];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double mind[n];<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)mind[i]=1e+18;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(used,0,sizeof(used));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>used[0]=1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>mind[i]=fabs(d[0][i]-m);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>prev[i]=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(t,1,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>double cost=1e+18;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int add=-1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(!used[i]&amp;&amp;cost&gt;mind[i]){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>cost=mind[i];<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>add=i;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">   </span>sum+=d[prev[add]][add];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>sum2+=d2[prev[add]][add];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>used[add]=1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(mind[i]&gt;fabs(d[add][i]-m)){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>mind[i]=min(mind[i],fabs(d[add][i]-m));<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>prev[i]=add;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>double minStdev(vector&lt;int&gt; x, vector&lt;int&gt; y) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>n=x.size();<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)FORE(j,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>d2[i][j]=(long long)(x[i]-x[j])*(x[i]-x[j])+(long long)(y[i]-y[j])*(y[i]-y[j]);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>d[i][j]=sqrt(d2[i][j]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;double&gt; m;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n)FORE(j,0,n)FORE(k,0,n)FORE(l,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>m.push_back((d[i][j]+d[k][l])/2.0+1e-8);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(all(m));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=1e+18;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,m.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>double sum=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>long long sum2=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>prim(m[i],sum,sum2);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>double ave=sum/(n-1);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>double ans=sqrt((sum2-2*sum*ave+(n-1)*ave*ave)/(n-1));<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret=min(ret,ans);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
