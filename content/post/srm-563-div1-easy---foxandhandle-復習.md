+++
title = "SRM 563 DIV1 Easy - FoxAndHandle (復習××)"
date = 2013-08-24T07:35:00Z
updated = 2015-03-26T19:36:33Z
tags = ["文字列"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=12331&amp;rd=15185" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=12331&amp;rd=15185</a><br /><br />文字列が与えられて、その文字をシャッフルして元の文字にランダムに挿入する。<br />挿入後の文字列が与えられた時、元の文字列のうち辞書順に最小のものを求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />文字の種類については、与えられた各文字を２で割ったものになる。<br />次に文字の順番については、ひとつ選ぶとその前の文字は選べなくなる。<br /><br />選ぶべき文字の種類を満たし、かつ辞書順になるよう小さいアルファベットから<br />上の判定を繰り返していく。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class FoxAndHandle {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: string lexSmallestName(string S) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int num[26]={0};<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>string ans="";<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,S.size())num[S[i]-'a']++;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,26)num[i]=num[i]/2;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>while(accumulate(num,num+26,0)&gt;0){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>pair&lt;char,int&gt; best=make_pair('z'+1,-1);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,S.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(num[S[i]-'a']==0)continue;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int count[26]={},invalid=0;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(j,i,S.size())count[S[j]-'a']++;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(j,0,26)if(num[j]&gt;count[j])invalid=1;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(invalid)continue;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">    </span>best=min(best,make_pair(S[i],i));<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ans+=best.first;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>num[best.first-'a']--;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>S=S.substr(best.second+1);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
