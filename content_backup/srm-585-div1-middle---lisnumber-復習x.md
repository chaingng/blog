+++
title = "SRM 585 DIV1 Middle - LISNumber （復習x）"
date = 2014-06-04T08:07:00Z
updated = 2014-06-17T19:08:35Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />０からiまでの数字のカードが与えられる。<br />各数字のカードは、cardsnum[i]枚だけ与えられる。<br /><br />このとき、カードを並べた時に左からみて増加列になっているサブ集合がＫだけ存在するようにしたい。<br /><br />サブ集合がＫとなるときの場合の数を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />いくつか例を出して考えてみる。<br />あるカードが並べられているとき、増加列が増えないときはその数字より小さいところに<br />カードを加えたときになる。<br /><br />つまりカードの大きさを小さい順に走査したとき、増加列の数Ｌだけ、増加列が増えない置き方が存在する。<br />現在のカードの枚数をＸとすると、組み合わせでＬ（Ｃ）Ｘ通りの置き方が存在する。<br />このうちＫ枚だけ増加列が増えないように置くとすると、Ｌ（Ｃ)Ｋとなる。<br /><br />また増加列が増えるときは、現在置かれているカード枚数をＳＵＭとしたとき、置き方はＳＵＭ＋１通り、<br />そこから上記の置き方を引くとＳＵＭ+1－（Ｌ－Ｘ）通りとなる。<br />こちらは重複組み合わせになるので、ＳＵＭ＋１－（Ｌ－Ｘ）（Ｈ）（Ｘ－Ｋ）通りとなる。<br /><br />上記をｄｐにて実装する。<br /><br />また、重複組み合わせはpCq=p+q-1Cqに変換でき、<br />組み合わせも以下の式よりｄｐで求めることができる。<br />xCy=x-1Cy-1+x-1Cy<br /><br />例えば5C3のとき、5枚から3枚を選ぶ組み合わせになる。<br />4C3は4枚から3枚選ぶ組み合わせになり、<br />さらに残りで選ばれていない1枚＋4枚から2枚選ぶ組み合わせの合計に分解できる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />int MOD=1000000007;<br />int dp[40][1300];<br />long long C[1300][1300];<br /><br />class LISNumber {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>long long hc(int a,int b){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return C[a+b-1][b];<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int count(vector&lt;int&gt; cardsnum, int K) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=cardsnum.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp,0,sizeof(dp));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>dp[0][0]=1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,1300)C[i][0]=C[i][i]=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,1300)FORE(j,1,i)C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int all=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(x,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int y=0;y&lt;=all;y++){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(dp[x][y]==0)continue;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>for(int z=0;z&lt;=y;z++){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>int left=cardsnum[x]-z;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>if(left&gt;=0){<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>dp[x+1][y+left]=( dp[x+1][y+left]+ ((dp[x][y]*C[y][z])%MOD)*hc(all+1-(y-z),left) )%MOD;<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>all+=cardsnum[x];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return (int)(dp[n][K]%MOD);<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
