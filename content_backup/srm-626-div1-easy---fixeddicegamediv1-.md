+++
title = "SRM 626 DIV1 Easy - FixedDiceGameDiv1 (×)"
date = 2014-11-05T18:55:00Z
updated = 2015-04-03T11:10:15Z
tags = ["確率"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13239&amp;rd=15859" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=13239&amp;rd=15859</a><br /><br />・AliceとBobでゲームを行う。<br />・Aliceはa個b面あるサイコロを投げ、Bobはc個d面あるサイコロを投げる。<br />・b面あるサイコロは1～bの数字が書かれており、d面あるサイコロは1～dの数字が書かれている。<br />・Aliceが勝った時、出た目の期待値を求める。<br />・Aliceが勝つケースがないときは-1を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />・まずAliceが勝つかどうか判定する。<br />・Bobの一番小さい数はcであるので、c+1以上の面が出るときに勝つことができる。<br />・次にAliceの勝つ面について、どれだけの確率があるか計算する。<br />・dpを用いればできそう。<br />・現在までに使ったサイコロの数、現在までの合計のスコアを持つdpを作れば<br />　場合の数は計算できる。<br />・確率として、勝つ面が出た時のすべての場合の数の和を取り、最後に割ってあげる。<br />・サンプルはすべて通った。<br /><br />→System Failed<br /><br />・Aliceだけの面をみていたが、Bobの面も見る必要がある。<br />・つまり、Aliceの勝つ数についての場合の数＊Bobがそれに負けるときの場合の数を足してあげ、<br />　その和を全てとり最後に割ってあげる必要がある。<br /><br />・反省：確率の問題に弱い・・・。基礎が足りないのを実感。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />class FixedDiceGameDiv1 {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: double getExpectation(int a, int b, int c, int d) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double dp1[a+1][2501],dp2[c+1][2501];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp1,0,sizeof(dp1));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp2,0,sizeof(dp2));<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>dp1[0][0]=dp2[0][0]=1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,a)FORE(j,0,2501)FORE(k,1,b+1)if(j+k&lt;=a*b)dp1[i+1][j+k]+=dp1[i][j];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,c)FORE(j,0,2501)FORE(k,1,d+1)if(j+k&lt;=c*d)dp2[i+1][j+k]+=dp2[i][j];<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>double ret=0.0,sum=0.0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,c+1,a*b+1){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>double p=0.0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(j,0,i)p+=dp2[c][j];<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>ret+=i*dp1[a][i]*p;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>sum+=dp1[a][i]*p;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ret ? ret/sum : -1;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
