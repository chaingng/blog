+++
title = "SRM580 DIV2 -Level2"
date = 2013-07-14T10:44:00Z
updated = 2015-04-03T11:59:36Z
tags = ["探索箇所限定"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3>①複数のうなぎが川を流れている。<br />②各うなぎは毎秒１の速さで進む。<br />③各うなぎに対し、最初に到達する時間ｔと、うなぎの長さｌが与えられる。<br />④うさぎは２回のｔ時刻だけ、うなぎを捕まえることができる。<br />　選んだｔに対し、そのときに流れているうなぎを全て捕まえることができる。<br />⑤このとき、捕まえることのできるうなぎの最大数を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />最初に全探索で考える。<br />各時刻に対しとらえることのできるうなぎの数を洗い出し、<br />全ての時刻から２つ時刻を選ぶ方法を全通り試して、最大のうなぎの数を返す。<br /><br />しかし今回はうなぎの長さが１０＾９となるため、<br />全ての時刻の全探索で解くことができない。<br /><br />では、選ぶ時刻の数を少なくすることはできないか？と考える。<br />もう少し考えると、うなぎの数が変化するのは頭と尾のときのみということがわかれば、<br />高々５０＊２＝１００通りの時刻を調べればよいことがわかる。<br />全体の計算量はＯ（１００＊５０＝５０００）なのでこの考え方で解くことができる。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class EelAndRabbit {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int getmax(vector&lt;int&gt; l, vector&lt;int&gt; t) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ans=0;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;int&gt; v;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>v.clear();<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,t.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>v.push_back(t[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>v.push_back(t[i]+l[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,v.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(j,i+1,v.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int cur=0;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(k,0,t.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">     </span>if( (t[k]&lt;=t[i] &amp;&amp; t[i]&lt;=t[k]+l[k]) || (t[k]&lt;=t[j] &amp;&amp; t[j]&lt;=t[k]+l[k]))cur++;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>ans=max(ans,cur);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return ans;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
