+++
title = "SRM 616 DIV1 Middle - ColorfulCoins　（復習×）"
date = 2014-05-25T19:48:00Z
updated = 2014-06-13T18:29:43Z
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br />硬貨が複数種類存在し、１枚当たりの価値value[i]があらかじめわかっている。<br />それぞれの硬貨は異なる色をしている。<br /><br />またＡＴＭが存在し、好きな回数だけ好きな金額を引き出すことができる。<br />引きだされる金額は、もっとも硬貨が少ないように引きだされる。<br /><br />このとき、すべての硬貨の色の価値を判定するために必要な最小の引き出し回数を求める。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">考えたこと</h3><br />サンプルより１度に引き出せないときは、ある硬貨の価値の半分の硬貨があり、かつ倍の価値の硬貨があるときに存在しそう。<br /><br />また各硬貨について他の硬貨にならないように一度に引き出せる枚数は、その次の硬貨の価値から割りだせそう。<br /><br /><br />では１度の引き出しについて枚数が異なるように選び、その組み合わせの最大化で解けるか。<br /><br />サンプルと照らし合わせると合わないので、もっと最小となる考え方がありそう。<br /><br />ここでEditorialを読む。<br /><br />基本的には、２進数で表せる数とビット数の関係を用いる。<br /><br />全てのコインが２枚まで引き出せると、２回の判定で９通りまで判定できる。<br /><br />（例）引き出されたコインの枚数<br />１回目：０　０　０　１　１　１　２　２　２<br />２回目：０　１　２　０　１　２　０　１　２<br /><br /><br />ただしすべてのコインが2回引き出せなくとも、１枚まで引き出せるコインが４枚までなら<br />上記の判定に含むことができる。<br />４枚というのは、２回の引き出しにおける０と１の組み合わせ数。<br />つまり引き出す回数がｎ回とすると、各コインの引き出せる最大の数ｘのコインがx^2までで<br />あればよい。<br /><br /><span style="color: red;">ただしExampleから、どのコインも少なくても１回は引き出さないといけない。</span><br /><br />これは引き出せる最大のコインの枚数でソートすると何枚目かの情報もわかるので、<br />各配列のi番目にある最大数xのコインについて x^2&gt;=i+2であるような最小のnを求めればよい。<br /><br />最後に、long longの割り算でint型に代入しようとするとintを超える、またはマイナスになるケースがあるので同じ型で取り扱う必要がある。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">class ColorfulCoins {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public: int minQueries(vector&lt;long long&gt; values) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>vector&lt;long long&gt; num;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=values.size();<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n-1)num.push_back( min(100LL,(long long)(values[i+1]/values[i])) );<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>sort(all(num));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(count,1,7){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>int ok=1;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>FORE(i,0,num.size()){<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>int x=1;<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>FORE(j,0,count)x*=(num[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">    </span>if(x&lt;i+2)ok=0;<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>if(ok)return count;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return 6;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
