+++
title = "SRM 616 DIV1 Easy - WakingUp (○)"
date = 2014-11-13T19:15:00Z
updated = 2015-03-26T19:06:30Z
tags = ["ループ"]
blogimport = true 
[author]
	name = "chngng"
	uri = "https://www.blogger.com/profile/14196381724208675248"
+++

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">問題 </h3><br /><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=13124&amp;rd=15849" target="_blank">http://community.topcoder.com/stat?c=problem_statement&amp;pm=13124&amp;rd=15849</a><br /><br />・Alexは深く眠っており、どれだけ眠りが深いかはわかっていない。<br />・ただし、1秒ごとにDずつ眠りが深くなっていく。<br />・目覚まし時計が複数あり、最初にどの時刻でなり、１回鳴るごとにへる眠りの深さの値と、何秒周期で鳴るかの情報がわかっている。<br />・このとき、Alexがいつか起きるときの最大の眠りの深さの値を求める。<br />・ただし、どれだけ眠りが深くてもいつかは目覚めるときは-1を返す。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">解き方 </h3><br />・目覚まし時計の数は最大50、間隔は最大10なので全探索で解けそう。<br />・各時間において増減する眠さの値を記憶しておけば、いつが最小化がわかり、つまり眠りの最大の深さがわかる。<br />・ただし、これだけではいつか目覚めるかどうかはわからない。<br />・なので周期を見つけ、次の周期に必ず値が小さくなるなら-1、そうでなければ答えがあることがわかる。<br />・周期としては各periodの最小公倍数＋最初に鳴る最大の時刻をとればよさそう。<br /><br />→System Passed<br /><br />・周期は最小公倍数を計算したが、単に1*2*3...*10=2520と固定してもよさそうだった。<br /><br /><h3 style="border-bottom: 2px solid slateblue; border-left: 8px solid navy; color: black; padding: 0px 0px 1px 5px;">コード </h3><br /><div style="background-color: #e3f2fb; border: 1px dotted #CCCCCC; padding: 5px;">using namespace std;<br /><br />#define all(c) (c).begin(),(c).end()<br />#define FORE(i,d,e) for(int i=d;i&lt;e;i++)<br />#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)<br />#define FORIT(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)<br />#define ISEQ(c) (c).begin(), (c).end()<br /><br />class WakingUp {<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>public:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int gcd(int x,int y){<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return y ? gcd(y,x%y) : x;<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span>int maxSleepiness(vector&lt;int&gt; period, vector&lt;int&gt; start, vector&lt;int&gt; volume, int D) {<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int n=period.size();<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int init=0,lcd=1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>init=max(init,start[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>lcd=lcd*period[i]/gcd(lcd,period[i]);<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ma=init+lcd*2+1;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int dp[ma];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>memset(dp,0,sizeof(dp));<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,n){<br /><span class="Apple-tab-span" style="white-space: pre;">   </span>for(int j=start[i];j&lt;=ma;j+=period[i])dp[j]-=volume[i];<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>}<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,1,ma)dp[i]=dp[i-1]+dp[i]+D;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>if(dp[init+lcd]&gt;dp[init+lcd*2])return -1;<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>int ret=1e+9;<br /><span class="Apple-tab-span" style="white-space: pre;">  </span>FORE(i,0,ma)ret=min(ret,dp[i]);<br /><br /><span class="Apple-tab-span" style="white-space: pre;">  </span>return abs(ret);<br /><span class="Apple-tab-span" style="white-space: pre;"> </span>}<br /><br />};</div></div>
